<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris Clone</title>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #000;
        font-family: Arial, sans-serif;
        color: #fff;
      }
      #gameArea {
        display: flex;
        align-items: flex-start;
      }
      #gameContainer {
        position: relative;
      }
      canvas {
        border: 2px solid #333;
        display: block;
      }
      #lightningCanvas {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
      }
      .menu {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border-radius: 10px;
        text-align: center;
      }
      button {
        margin: 10px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
      }
      button:hover {
        background-color: #45a049;
      }
      #hud {
        margin-left: 20px;
        padding: 10px;
        background-color: rgba(0, 0, 0, 0.8);
        border: 2px solid #333;
        width: 150px;
      }
      #hud h3 {
        margin-top: 0;
        color: #4caf50;
      }
    </style>
  </head>
  <body>
    <div id="gameArea">
      <div id="gameContainer">
        <canvas id="tetrisCanvas" width="300" height="600"></canvas>
        <canvas id="lightningCanvas" width="300" height="600"></canvas>
        <div id="startMenu" class="menu">
          <h2>Tetris Clone</h2>
          <button id="startButton">Start Game</button>
        </div>
        <div id="pauseMenu" class="menu" style="display: none">
          <h2>Paused</h2>
          <button id="resumeButton">Resume</button>
          <button id="restartButton">Restart</button>
          <button id="quitButton">Quit to Menu</button>
        </div>
      </div>
      <div id="hud">
        <h3>Score</h3>
        <p id="scoreDisplay">0</p>
        <h3>Level</h3>
        <p id="levelDisplay">1</p>
        <h3>Lines</h3>
        <p id="linesDisplay">0</p>
      </div>
    </div>
    <script>
      const canvas = document.getElementById("tetrisCanvas");
      const ctx = canvas.getContext("2d");
      const lightningCanvas = document.getElementById("lightningCanvas");
      const lightningCtx = lightningCanvas.getContext("2d");
      const BLOCK_SIZE = 30;
      const BOARD_WIDTH = 10;
      const BOARD_HEIGHT = 20;

      let board = Array(BOARD_HEIGHT)
        .fill()
        .map(() => Array(BOARD_WIDTH).fill(0));
      let currentPiece;
      let currentX;
      let currentY;
      let currentColor;
      let gameInterval;
      let gameState = "menu"; // 'menu', 'playing', 'paused', 'gameover'
      let score = 0;
      let level = 1;
      let lines = 0;

      const SHAPES = [
        [[1, 1, 1, 1]],
        [
          [1, 1],
          [1, 1],
        ],
        [
          [1, 1, 1],
          [0, 1, 0],
        ],
        [
          [1, 1, 1],
          [1, 0, 0],
        ],
        [
          [1, 1, 1],
          [0, 0, 1],
        ],
        [
          [1, 1, 0],
          [0, 1, 1],
        ],
        [
          [0, 1, 1],
          [1, 1, 0],
        ],
      ];

      const COLORS = [
        "#00FFFF",
        "#FFFF00",
        "#800080",
        "#FF0000",
        "#0000FF",
        "#00FF00",
        "#FFA500",
      ];

      function newPiece() {
        const shapeIndex = Math.floor(Math.random() * SHAPES.length);
        currentPiece = SHAPES[shapeIndex];
        currentColor = COLORS[shapeIndex];
        currentX =
          Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece[0].length / 2);
        currentY = 0;

        if (!isValidMove(0, 0)) {
          gameOver();
        }
      }

      function draw() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw board
        for (let y = 0; y < BOARD_HEIGHT; y++) {
          for (let x = 0; x < BOARD_WIDTH; x++) {
            if (board[y][x]) {
              ctx.fillStyle = board[y][x];
              ctx.fillRect(
                x * BLOCK_SIZE,
                y * BLOCK_SIZE,
                BLOCK_SIZE,
                BLOCK_SIZE
              );
              ctx.strokeStyle = "#000";
              ctx.strokeRect(
                x * BLOCK_SIZE,
                y * BLOCK_SIZE,
                BLOCK_SIZE,
                BLOCK_SIZE
              );
            }
          }
        }

        // Draw current piece
        ctx.fillStyle = currentColor;
        for (let y = 0; y < currentPiece.length; y++) {
          for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x]) {
              ctx.fillRect(
                (currentX + x) * BLOCK_SIZE,
                (currentY + y) * BLOCK_SIZE,
                BLOCK_SIZE,
                BLOCK_SIZE
              );
              ctx.strokeStyle = "#000";
              ctx.strokeRect(
                (currentX + x) * BLOCK_SIZE,
                (currentY + y) * BLOCK_SIZE,
                BLOCK_SIZE,
                BLOCK_SIZE
              );
            }
          }
        }
      }

      function isValidMove(offsetX, offsetY, newPiece = currentPiece) {
        for (let y = 0; y < newPiece.length; y++) {
          for (let x = 0; x < newPiece[y].length; x++) {
            if (newPiece[y][x]) {
              let newX = currentX + x + offsetX;
              let newY = currentY + y + offsetY;
              if (
                newX < 0 ||
                newX >= BOARD_WIDTH ||
                newY >= BOARD_HEIGHT ||
                (newY >= 0 && board[newY][newX])
              ) {
                return false;
              }
            }
          }
        }
        return true;
      }

      function rotate() {
        let newPiece = currentPiece[0].map((val, index) =>
          currentPiece.map((row) => row[index]).reverse()
        );
        if (isValidMove(0, 0, newPiece)) {
          currentPiece = newPiece;
        }
      }

      function merge() {
        for (let y = 0; y < currentPiece.length; y++) {
          for (let x = 0; x < currentPiece[y].length; x++) {
            if (currentPiece[y][x]) {
              board[currentY + y][currentX + x] = currentColor;
            }
          }
        }
      }

      function clearLines() {
        let linesCleared = 0;
        for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
          if (board[y].every((cell) => cell !== 0)) {
            board.splice(y, 1);
            board.unshift(Array(BOARD_WIDTH).fill(0));
            linesCleared++;
            y++; // Check the new line that dropped down
            drawLightning();
          }
        }
        if (linesCleared > 0) {
          lines += linesCleared;
          score += calculateScore(linesCleared);
          level = Math.floor(lines / 10) + 1;
          updateHUD();
          adjustDifficulty();
        }
      }

      function calculateScore(linesCleared) {
        const linePoints = [40, 100, 300, 1200]; // Points for 1, 2, 3, 4 lines
        return linePoints[linesCleared - 1] * level;
      }

      function adjustDifficulty() {
        clearInterval(gameInterval);
        const speed = Math.max(100, 500 - (level - 1) * 20); // Decrease interval by 20ms per level, min 100ms
        gameInterval = setInterval(moveDown, speed);
      }

      function updateHUD() {
        document.getElementById("scoreDisplay").textContent = score;
        document.getElementById("levelDisplay").textContent = level;
        document.getElementById("linesDisplay").textContent = lines;
      }

      function moveDown() {
        if (isValidMove(0, 1)) {
          currentY++;
        } else {
          merge();
          clearLines();
          newPiece();
        }
        draw();
      }

      function gameOver() {
        gameState = "gameover";
        clearInterval(gameInterval);
        alert(`Game Over! Your score: ${score}`);
        showStartMenu();
      }

      function startGame() {
        board = Array(BOARD_HEIGHT)
          .fill()
          .map(() => Array(BOARD_WIDTH).fill(0));
        score = 0;
        level = 1;
        lines = 0;
        updateHUD();
        newPiece();
        gameState = "playing";
        adjustDifficulty();
        document.getElementById("startMenu").style.display = "none";
        document.getElementById("pauseMenu").style.display = "none";
      }

      function pauseGame() {
        if (gameState === "playing") {
          gameState = "paused";
          clearInterval(gameInterval);
          document.getElementById("pauseMenu").style.display = "block";
        }
      }

      function resumeGame() {
        if (gameState === "paused") {
          gameState = "playing";
          adjustDifficulty();
          document.getElementById("pauseMenu").style.display = "none";
        }
      }

      function showStartMenu() {
        gameState = "menu";
        document.getElementById("startMenu").style.display = "block";
        document.getElementById("pauseMenu").style.display = "none";
      }

      function drawLightning() {
        lightningCtx.clearRect(
          0,
          0,
          lightningCanvas.width,
          lightningCanvas.height
        );
        lightningCtx.strokeStyle = "rgba(128, 0, 128, 0.8)";
        lightningCtx.lineWidth = 2;
        lightningCtx.beginPath();
        lightningCtx.moveTo(Math.random() * lightningCanvas.width, 0);

        let y = 0;
        while (y < lightningCanvas.height) {
          let x = Math.random() * lightningCanvas.width;
          y += Math.random() * 50 + 50;
          lightningCtx.lineTo(x, y);
        }

        lightningCtx.stroke();

        setTimeout(() => {
          lightningCtx.clearRect(
            0,
            0,
            lightningCanvas.width,
            lightningCanvas.height
          );
        }, 100);
      }

      document.addEventListener("keydown", (event) => {
        if (gameState === "playing") {
          switch (event.keyCode) {
            case 37: // Left arrow
              if (isValidMove(-1, 0)) currentX--;
              break;
            case 39: // Right arrow
              if (isValidMove(1, 0)) currentX++;
              break;
            case 40: // Down arrow
              moveDown();
              break;
            case 38: // Up arrow
              rotate();
              break;
            case 80: // 'P' key
            case 27: // ESC key
              pauseGame();
              break;
          }
          draw();
        } else if (gameState === "paused" && event.keyCode === 27) {
          // ESC key
          resumeGame();
        }
      });

      document
        .getElementById("startButton")
        .addEventListener("click", startGame);
      document
        .getElementById("resumeButton")
        .addEventListener("click", resumeGame);
      document
        .getElementById("restartButton")
        .addEventListener("click", startGame);
      document
        .getElementById("quitButton")
        .addEventListener("click", showStartMenu);

      showStartMenu();
    </script>
  </body>
</html>
